{"version":3,"names":["ESLINT_VERSION","require","convertTemplateType","tokens","tl","curlyBrace","templateTokens","result","addTemplateType","start","end","length","value","reduce","token","type","label","template","push","loc","forEach","backQuote","dollarBraceL","braceR","convertToken","source","newToken","range","name","tokenValue","semi","comma","parenL","parenR","braceL","slash","dot","bracketL","bracketR","ellipsis","arrow","pipeline","star","incDec","colon","question","at","logicalOR","logicalAND","nullishCoalescing","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","exponent","bang","tilde","doubleColon","hash","questionDot","braceHashL","braceBarL","braceBarR","bracketHashL","bracketBarL","bracketBarR","doubleCaret","doubleAt","isAssign","_newToken$value","jsxTagStart","jsxTagEnd","jsxName","jsxText","keyword","num","slice","string","regexp","regex","pattern","flags","bigint","privateName","templateNonTail","templateTail","Template","module","exports","convertTokens","code","tokLabels","templateTypeMergedTokens","i","tokenType","nextToken","column"],"sources":["../../src/convert/convertTokens.cts"],"sourcesContent":["import type { BabelToken } from \"../types.cts\";\nimport type * as t from \"@babel/types\";\nimport ESLINT_VERSION = require(\"../utils/eslint-version.cjs\");\n\nfunction convertTemplateType(tokens: BabelToken[], tl: Record<string, any>) {\n  let curlyBrace: BabelToken = null;\n  let templateTokens: BabelToken[] = [];\n  const result: any[] = [];\n\n  function addTemplateType() {\n    const start = templateTokens[0];\n    const end = templateTokens[templateTokens.length - 1];\n\n    const value = templateTokens.reduce((result, token) => {\n      if (token.value) {\n        result += token.value;\n      } else if (token.type.label !== tl.template) {\n        result += token.type.label;\n      }\n\n      return result;\n    }, \"\");\n\n    result.push({\n      type: \"Template\",\n      value: value,\n      start: start.start,\n      end: end.end,\n      loc: {\n        start: start.loc.start,\n        end: end.loc.end,\n      },\n    });\n\n    templateTokens = [];\n  }\n\n  tokens.forEach(token => {\n    switch (token.type.label) {\n      case tl.backQuote:\n        if (curlyBrace) {\n          result.push(curlyBrace);\n          curlyBrace = null;\n        }\n\n        templateTokens.push(token);\n\n        if (templateTokens.length > 1) {\n          addTemplateType();\n        }\n\n        break;\n\n      case tl.dollarBraceL:\n        templateTokens.push(token);\n        addTemplateType();\n        break;\n\n      case tl.braceR:\n        if (curlyBrace) {\n          result.push(curlyBrace);\n        }\n\n        curlyBrace = token;\n        break;\n\n      case tl.template:\n        if (curlyBrace) {\n          templateTokens.push(curlyBrace);\n          curlyBrace = null;\n        }\n\n        templateTokens.push(token);\n        break;\n\n      default:\n        if (curlyBrace) {\n          result.push(curlyBrace);\n          curlyBrace = null;\n        }\n\n        result.push(token);\n    }\n  });\n\n  return result;\n}\n\nfunction convertToken(\n  token: BabelToken,\n  source: string,\n  tl: Record<string, any>,\n) {\n  const { type } = token;\n  const { label } = type;\n\n  const newToken: {\n    type: string;\n    range?: [number, number];\n    value?: string;\n    regex?: {\n      pattern: string;\n      flags: string;\n    };\n    loc?: t.SourceLocation | null;\n  } = token as any;\n  newToken.range = [token.start, token.end];\n\n  if (label === tl.name) {\n    const tokenValue = token.value;\n    if (\n      tokenValue === \"let\" ||\n      tokenValue === \"static\" ||\n      tokenValue === \"yield\"\n    ) {\n      newToken.type = \"Keyword\";\n    } else {\n      newToken.type = \"Identifier\";\n    }\n  } else if (\n    label === tl.semi ||\n    label === tl.comma ||\n    label === tl.parenL ||\n    label === tl.parenR ||\n    label === tl.bra